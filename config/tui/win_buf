" To change current directory automatically according to opened file in current window
set autochdir

" Switch windows
noremap <C-w> <C-w>w
inoremap <C-w> <C-O><C-w>w
snoremap <C-w> <Esc><C-w>w
cnoremap <C-w> <C-O><C-w>w
onoremap <C-w> <C-O><C-w>w
"     in 'terminal' mode
tnoremap <C-w> <C-\><C-N><C-w>wi

" Switch tabs
noremap <silent> <C-Up> :tabprev<CR>
inoremap <silent> <C-Up> <C-O>:tabprev<CR>
snoremap <silent> <C-Up> <Esc>:tabprev<CR>
cnoremap <silent> <C-Up> <C-O>:tabprev<CR>
onoremap <silent> <C-Up> <C-O>:tabprev<CR>

noremap <silent> <C-Down> :tabnext<CR>
inoremap <silent> <C-Down> <C-O>:tabnext<CR>
snoremap <silent> <C-Down> <Esc>:tabnext<CR>
cnoremap <silent> <C-Down> <C-O>:tabnext<CR>
onoremap <silent> <C-Down> <C-O>:tabnext<CR>

" Close tab
noremap <M-q> :tabclose<CR>
inoremap <M-q> <C-O>:tabclose<CR>

" Close window without closing buffer
noremap <M-c> <C-w>c
inoremap <M-c> <C-O><C-w>c
cnoremap <M-c> <C-O><C-w>c
onoremap <M-c> <C-O><C-w>c
"     in 'terminal' mode
tnoremap <M-c> <C-\><C-N><C-w>c

function! s:IsCurrBufQuickFix()
    return &filetype == 'qf'
endfunction

function! s:IsCurrWindowQuickFix()
    return exists("w:quickfix_title")
endfunction

" Close buffer without closing window
" Do not switch to 'QuickFix' buffer on it's existence
function! NvimIdeCloseCurrBuf()
    if s:IsCurrWindowQuickFix()
        call NvimIdeClearAndCloseQuickfix()
        return
    endif

    let mruBufs = fzf#vim#_buflisted_sorted()

    if len(mruBufs) < 2
        throw "NvimIde: failed to close the only file buffer"
    endif

    if &modified
        throw "NvimIde: failed to close modified buffer"
    endif

    exe 'silent b' . mruBufs[1]
    exe 'bd ' . mruBufs[0]
endfunction

noremap <silent> <M-x> :call NvimIdeCloseCurrBuf()<CR>
inoremap <silent> <M-x> <C-O>:call NvimIdeCloseCurrBuf()<CR>

" Code window markers
function! NvimIdeMarkCodeWindow()
    let w:nvim_ide_is_code_window = v:true
endfunction

function! NvimIdeIsCodeWindow()
    if exists("w:nvim_ide_is_code_window")
        return w:nvim_ide_is_code_window
    endif

    return v:false
endfunction

"     this function should be called on startup to mark initial window as 'code' window
call NvimIdeMarkCodeWindow()

" Split window vertically
noremap <silent> <M-\> <C-w>v:call NvimIdeMarkCodeWindow()<CR><C-w>w
inoremap <silent> <M-\> <C-O><C-w>v<C-o>:call NvimIdeMarkCodeWindow()<CR><C-o><C-w>w

" Split windows horizontally
noremap <silent> <M--> <C-w>s:call NvimIdeMarkCodeWindow()<CR><C-w>w
inoremap <silent> <M--> <C-O><C-w>s<C-o>:call NvimIdeMarkCodeWindow()<CR><C-o><C-w>w

" Switch buffers
function! s:ShowFzfBuffers()
    call fzf#vim#buffers()
endfunction

function! s:GotoCodeWindow()
    if NvimIdeIsCodeWindow()
        return v:true
    endif

    let initialWin = win_getid()
    let codeWin = -1
    while v:true
       wincmd w
       let currWin = win_getid()

       if NvimIdeIsCodeWindow()
           if codeWin == -1
               let codeWin = currWin
           else
               call NvimIdeEchoWarning("More than 1 code window. Switch to code window manually and choose the buffer.")
               call win_gotoid(initialWin)
               return v:false
           endif
       endif

       if currWin == initialWin
           break
       endif
    endwhile

    if codeWin == -1
        call NvimIdeEchoWarning("No code window(s).")
        call win_gotoid(initialWin)
        return v:false
    endif

    call win_gotoid(codeWin)
    return v:true
endfunction

function! NvimIdeBuffers()
    if !s:GotoCodeWindow()
        return
    endif

    let effectiveRoot = g:nvim_ide_start_dir
    if exists("g:nvim_ide_project_root")
        let effectiveRoot = g:nvim_ide_project_root
    endif

    let cwd_au = getcwd()
    exe 'cd ' . effectiveRoot
    call s:ShowFzfBuffers()
    exe 'cd ' . cwd_au
endfunction

inoremap <C-PageUp> <C-o>:call NvimIdeBuffers()<CR>
nnoremap <C-PageUp> :call NvimIdeBuffers()<CR>
tnoremap <C-PageUp> <C-\><C-N>:call NvimIdeBuffers()<CR>
inoremap <C-PageDown> <C-o>:call NvimIdeBuffers()<CR>
nnoremap <C-PageDown> :call NvimIdeBuffers()<CR>
tnoremap <C-PageDown> <C-\><C-N>:call NvimIdeBuffers()<CR>

" Win/Buf navigation using 'jumps'
" TODO: test 'set jumpoptions+=stack' behaviour

augroup NvimIdeWindows
    autocmd!
    autocmd VimEnter * clearjumps
augroup END

function! NvimIdeJumpPrev()
    if s:GotoCodeWindow()
        exe "normal! \<C-o>zz"
    endif
endfunction

function! NvimIdeJumpNext()
    if s:GotoCodeWindow()
        exe "normal! \<C-i>zz"
    endif
endfunction

noremap <M-left> :call NvimIdeJumpPrev()<CR>
inoremap <M-left> <C-o>: call NvimIdeJumpPrev()<CR>
smap <M-left> <Esc><M-left>

noremap <M-right> :call NvimIdeJumpNext()<CR>
inoremap <M-right> <C-o>: call NvimIdeJumpNext()<CR>
smap <M-right> <Esc><M-right>

" Quickfix window

" TODO: 'has_quickfix_movements' detection should be rewritten: set var local for quickfix buffer which indicates should we move farward or not

let s:has_quickfix_movements = 0
augroup NvimIdeQuickfix
    autocmd!
    autocmd BufReadPost quickfix let s:has_quickfix_movements = 0
augroup END

function! NvimIdeCenterText()
    normal! zz
endfunction

"     Next/prev in quickfix window. Quickfix is used for search results, 'LSP usage' results, etc.
function! NvimIdeJumpQFItem(f)
    exe a:f
    call NvimIdeCenterText()
endfunction

function! NvimIdeNextQFItem()
    let f = (s:has_quickfix_movements ? "cn" : "cc")

    call NvimIdeJumpQFItem(f)
    let s:has_quickfix_movements = 1
endfunction

"     item
nnoremap <M-down> :call NvimIdeNextQFItem()<CR>
inoremap <M-down> <C-o>:call NvimIdeNextQFItem()<CR>
smap <M-down> <Esc><M-down>
nnoremap <M-up> :call NvimIdeJumpQFItem("cp")<CR>
inoremap <M-up> <C-o>:call NvimIdeJumpQFItem("cp")<CR>
smap <M-up> <Esc><M-up>
"     file
nnoremap <C-M-down> :call NvimIdeJumpQFItem("cnf")<CR>
inoremap <C-M-down> <C-o>:call NvimIdeJumpQFItem("cnf")<CR>
smap <C-M-down> <Esc><C-M-down>
nnoremap <C-M-up> :call NvimIdeJumpQFItem("cpf")<CR>
inoremap <C-M-up> <C-o>:call NvimIdeJumpQFItem("cpf")<CR>
smap <C-M-up> <Esc><C-M-up>

"     Close quickfix window.
function! NvimIdeClearAndCloseQuickfix()
    let is_qf = s:IsCurrBufQuickFix()
    cclose
    cexpr []
    if is_qf
        wincmd p
    endif
endfunction

" TODO: possibly detection quickfix existence should be checked to close it under condition and move to insert mode
nnoremap <silent> <Esc> :call NvimIdeClearAndCloseQuickfix()<CR>i

function! NvimIdeQuickfixPostprocess(ptrn)
    call v:lua.NvimIdeHighlightQuickfix(a:ptrn)
    " Goto previous windows (probably with code)
    wincmd p
endfunction

