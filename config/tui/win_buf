" To change current directory automatically according to opened file in current window
set autochdir

" Switch windows
noremap <C-w> <C-w>w
inoremap <C-w> <C-O><C-w>w
snoremap <C-w> <Esc><C-w>w
cnoremap <C-w> <C-O><C-w>w
onoremap <C-w> <C-O><C-w>w
"     in 'terminal' mode
tnoremap <C-w> <C-\><C-N><C-w>wi

" Switch tabs
noremap <silent> <C-Up> :tabprev<CR>
inoremap <silent> <C-Up> <C-O>:tabprev<CR>
snoremap <silent> <C-Up> <Esc>:tabprev<CR>
cnoremap <silent> <C-Up> <C-O>:tabprev<CR>
onoremap <silent> <C-Up> <C-O>:tabprev<CR>

noremap <silent> <C-Down> :tabnext<CR>
inoremap <silent> <C-Down> <C-O>:tabnext<CR>
snoremap <silent> <C-Down> <Esc>:tabnext<CR>
cnoremap <silent> <C-Down> <C-O>:tabnext<CR>
onoremap <silent> <C-Down> <C-O>:tabnext<CR>

" Close tab
noremap <M-q> :tabclose<CR>
inoremap <M-q> <C-O>:tabclose<CR>

" Close window without closing buffer
noremap <M-c> <C-w>c
inoremap <M-c> <C-O><C-w>c
cnoremap <M-c> <C-O><C-w>c
onoremap <M-c> <C-O><C-w>c
"     in 'terminal' mode
tnoremap <M-c> <C-\><C-N><C-w>c

function! s:IsCurrBufQuickFix()
    return &filetype == 'qf'
endfunction

" Close buffer without closing window
" Do not switch to 'QuickFix' buffer on it's existence
function! NvimIdeCloseCurrBuf()
    let currBuf = bufnr()
    if getbufinfo(currBuf)[0].changed == 1
        throw "NvimIde: failed to close modified buffer"
    endif

    exe 'silent bn'

    let err = ""
    try
        if s:IsCurrBufQuickFix()
            exe 'silent bn'
            if bufnr() == currBuf
                let err = "NvimIde: failed to close the only file buffer"
            endif
        endif
    catch
    endtry

    if len(err)
        throw err
    endif

    exe 'bd '.currBuf
endfunction

noremap <silent> <M-x> :call NvimIdeCloseCurrBuf()<CR>
inoremap <silent> <M-x> <C-O>:call NvimIdeCloseCurrBuf()<CR>

" Code window markers
function! NvimIdeMarkCodeWindow()
    let w:nvim_ide_is_code_window = v:true
endfunction

function! NvimIdeIsCodeWindow()
    if exists("w:nvim_ide_is_code_window")
        return w:nvim_ide_is_code_window
    endif

    return v:false
endfunction

"     this function should be called on startup to mark initial window as 'code' window
call NvimIdeMarkCodeWindow()

" Split window vertically
noremap <silent> <M-m> <C-w>v:call NvimIdeMarkCodeWindow()<CR><C-w>w
inoremap <silent> <M-m> <C-O><C-w>v<C-o>:call NvimIdeMarkCodeWindow()<CR><C-o><C-w>w

" Switch buffers
function! s:ShowFzfBuffers()
    call fzf#vim#buffers()
endfunction

function! s:GotoCodeWindow()
    if NvimIdeIsCodeWindow()
        return v:true
    endif

    let initialWin = win_getid()
    let codeWin = -1
    while v:true
       wincmd w
       let currWin = win_getid()

       if NvimIdeIsCodeWindow()
           if codeWin == -1
               let codeWin = currWin
           else
               call NvimIdeEchoWarning("More than 1 code window. Switch to code window manually and choose the buffer.")
               call win_gotoid(initialWin)
               return v:false
           endif
       endif

       if currWin == initialWin
           break
       endif
    endwhile

    if codeWin == -1
        call NvimIdeEchoWarning("No code window(s).")
        call win_gotoid(initialWin)
        return v:false
    endif

    call win_gotoid(codeWin)
    return v:true
endfunction

function! NvimIdeBuffers()
    if !s:GotoCodeWindow()
        return
    endif

    if !exists("g:nvim_ide_project_root")
        call s:ShowFzfBuffers()
        return
    endif

    let l:cwd_au = getcwd()
    exe 'cd '.g:nvim_ide_project_root
    call s:ShowFzfBuffers()
    exe 'cd '.l:cwd_au
endfunction

inoremap <C-PageUp> <C-o>:call NvimIdeBuffers()<CR>
nnoremap <C-PageUp> :call NvimIdeBuffers()<CR>
tnoremap <C-PageUp> <C-\><C-N>:call NvimIdeBuffers()<CR>
inoremap <C-PageDown> <C-o>:call NvimIdeBuffers()<CR>
nnoremap <C-PageDown> :call NvimIdeBuffers()<CR>
tnoremap <C-PageDown> <C-\><C-N>:call NvimIdeBuffers()<CR>

" Win/Buf navigation using 'jumps'
" TODO: test 'set jumpoptions+=stack' behaviour

augroup NvimIdeWindows
    autocmd!
    autocmd VimEnter * clearjumps
augroup END

noremap <M-left> <C-o>zz
inoremap <M-left> <C-o><C-o><C-o>zz
snoremap <M-left> <Esc><C-o>zz

noremap <M-right> <C-i>zz
inoremap <M-right> <C-o><C-i><C-o>zz
snoremap <M-right> <Esc><C-i>zz

" Quickfix window

" TODO: 'has_quickfix_movements' detection should be rewritten: set var local for quickfix buffer which indicates should we move farward or not

let s:has_quickfix_movements = 0
augroup NvimIdeQuickfix
    autocmd!
    autocmd BufReadPost quickfix let s:has_quickfix_movements = 0
augroup END

"     Next/prev in quickfix window. Quickfix is used for search results, 'LSP usage' results, etc.
function! NvimIdeNextQFItem(mode)
    if s:has_quickfix_movements
        cn
    else
        cc
    endif
    let s:has_quickfix_movements = 1

    let special_symbol = ""
    if a:mode == "i"
        let special_symbol = nvim_replace_termcodes("<C-o>", v:true, v:false, v:true)
    endif

    call feedkeys(special_symbol . "zz")
endfunction

"     item
nnoremap <M-down> :call NvimIdeNextQFItem("")<CR>
inoremap <M-down> <C-o>:call NvimIdeNextQFItem("i")<CR>
nnoremap <M-up> :cp<CR>
inoremap <M-up> <C-o>:cp<CR>
"     file
nnoremap <C-M-down> :cnf<CR>
inoremap <C-M-down> <C-o>:cnf<CR>
nnoremap <C-M-up> :cpf<CR>
inoremap <C-M-up> <C-o>:cpf<CR>

"     Close quickfix window.
function! NvimIdeClearAndCloseQuickfix()
    let is_qf = s:IsCurrBufQuickFix()
    cclose
    cexpr []
    if is_qf
        wincmd p
    endif
endfunction

" TODO: possibly detection quickfix existence should be checked to close it under condition and move to insert mode
nnoremap <silent> <Esc> :call NvimIdeClearAndCloseQuickfix()<CR>i

" Highlight function
function! NvimIdeHighlightResults(isInsertMode, ptrn)
    let @/=escape(substitute(a:ptrn, '"', '', 'g'), '|')

    if a:isInsertMode
        call feedkeys("\<C-o>:let &hlsearch=1\<CR>", 'n')
    else
        call feedkeys(":let &hlsearch=1\<CR>", 'n')
    endif
endfunction

function! NvimIdeQuickfixPostprocess(isInsertMode, ptrn)
    call NvimIdeHighlightResults(a:isInsertMode, a:ptrn)
    " Goto previous windows (probably with code)
    " wincmd p
endfunction

